// Code generated by sqlc. DO NOT EDIT.
// This file will be generated by sqlc generate command

package db

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"time"
)

// This is a placeholder file. Run 'sqlc generate' to generate the actual code.

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}

// Placeholder structs - these will be generated by sqlc
type Flight struct {
	ID            int64     `json:"id"`
	Origin        string    `json:"origin"`
	Destination   string    `json:"destination"`
	DepartureTime time.Time `json:"departure_time"`
	ArrivalTime   time.Time `json:"arrival_time"`
	Airline       string    `json:"airline"`
	Aircraft      string    `json:"aircraft"`
	FareClass     string    `json:"fare_class"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

type Seat struct {
	ID        int64     `json:"id"`
	FlightID  int64     `json:"flight_id"`
	SeatNo    string    `json:"seat_no"`
	Class     string    `json:"class"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type SeatLock struct {
	ID        int64      `json:"id"`
	FlightID  int64      `json:"flight_id"`
	SeatNo    string     `json:"seat_no"`
	HolderID  string     `json:"holder_id"`
	ExpiresAt *time.Time `json:"expires_at"`
	CreatedAt time.Time  `json:"created_at"`
	UpdatedAt time.Time  `json:"updated_at"`
}

type Ticket struct {
	ID          int64     `json:"id"`
	FlightID    int64     `json:"flight_id"`
	SeatNo      string    `json:"seat_no"`
	UserID      string    `json:"user_id"`
	PriceAmount int64     `json:"price_amount"`
	Currency    string    `json:"currency"`
	IssuedAt    time.Time `json:"issued_at"`
	PnrCode     string    `json:"pnr_code"`
	PaymentRef  string    `json:"payment_ref"`
	CreatedAt   time.Time `json:"created_at"`
}

type IdempotencyKey struct {
	RequestID    string    `json:"request_id"`
	Route        string    `json:"route"`
	UserID       string    `json:"user_id"`
	ResponseHash string    `json:"response_hash"`
	CreatedAt    time.Time `json:"created_at"`
}

// Placeholder parameter structs - these will be generated by sqlc
type GetFlightParams struct {
	ID int64
}

type CreateFlightParams struct {
	Origin        string
	Destination   string
	DepartureTime time.Time
	ArrivalTime   time.Time
	Airline       string
	Aircraft      string
	FareClass     string
}

type CreateSeatParams struct {
	FlightID int64
	SeatNo   string
	Class    string
}

type CreateSeatLockParams struct {
	FlightID  int64
	SeatNo    string
	HolderID  string
	ExpiresAt *time.Time
}

type UpdateSeatLockParams struct {
	HolderID   string
	ExpiresAt  *time.Time
	FlightID   int64
	SeatNo     string
	HolderID_2 string
}

type ConfirmSeatLockParams struct {
	FlightID int64
	SeatNo   string
	HolderID string
}

type ReleaseSeatLockParams struct {
	FlightID int64
	SeatNo   string
	HolderID string
}

type GetSeatLockParams struct {
	FlightID int64
	SeatNo   string
}

type CreateTicketParams struct {
	FlightID    int64
	SeatNo      string
	UserID      string
	PriceAmount int64
	Currency    string
	PnrCode     string
	PaymentRef  string
}

type GetTicketByPNRParams struct {
	PnrCode string
}

type GetTicketByFlightSeatParams struct {
	FlightID int64
	SeatNo   string
}

type CreateIdempotencyKeyParams struct {
	RequestID    string
	Route        string
	UserID       string
	ResponseHash string
}

type GetIdempotencyKeyParams struct {
	RequestID string
	Route     string
}

// Placeholder method implementations - these will be generated by sqlc
func (q *Queries) GetFlight(ctx context.Context, id int64) (Flight, error) {
	query := `SELECT id, origin, destination, departure_time, arrival_time, airline, aircraft, fare_class, created_at, updated_at
	FROM flights WHERE id = ?`
	
	var f Flight
	err := q.db.QueryRowContext(ctx, query, id).Scan(
		&f.ID, &f.Origin, &f.Destination, &f.DepartureTime, &f.ArrivalTime,
		&f.Airline, &f.Aircraft, &f.FareClass, &f.CreatedAt, &f.UpdatedAt,
	)
	
	return f, err
}

func (q *Queries) CreateFlight(ctx context.Context, arg CreateFlightParams) (int64, error) {
	query := `INSERT INTO flights (origin, destination, departure_time, arrival_time, airline, aircraft, fare_class)
	VALUES (?, ?, ?, ?, ?, ?, ?)`
	
	// Log dos parÃ¢metros para debug
	log.Printf("DEBUG CreateFlight - Origin: %s, Destination: %s, Airline: %s", 
		arg.Origin, arg.Destination, arg.Airline)
	log.Printf("DEBUG CreateFlight - DepartureTime: %v, ArrivalTime: %v", 
		arg.DepartureTime, arg.ArrivalTime)
	
	result, err := q.db.ExecContext(ctx, query, 
		arg.Origin, arg.Destination, arg.DepartureTime, arg.ArrivalTime,
		arg.Airline, arg.Aircraft, arg.FareClass)
	if err != nil {
		log.Printf("DEBUG CreateFlight - Error executing query: %v", err)
		return 0, fmt.Errorf("failed to execute insert: %w", err)
	}
	
	id, err := result.LastInsertId()
	if err != nil {
		log.Printf("DEBUG CreateFlight - Error getting LastInsertId: %v", err)
		return 0, fmt.Errorf("failed to get last insert ID: %w", err)
	}
	
	log.Printf("DEBUG CreateFlight - Success! ID: %d", id)
	return id, nil
}

func (q *Queries) CreateSeat(ctx context.Context, arg CreateSeatParams) (int64, error) {
	query := `INSERT INTO seats (flight_id, seat_no, class) VALUES (?, ?, ?)`
	
	result, err := q.db.ExecContext(ctx, query, arg.FlightID, arg.SeatNo, arg.Class)
	if err != nil {
		return 0, err
	}
	
	return result.LastInsertId()
}

func (q *Queries) ListSeats(ctx context.Context, flightID int64) ([]Seat, error) {
	query := `SELECT id, flight_id, seat_no, class, created_at, updated_at 
	FROM seats WHERE flight_id = ? ORDER BY seat_no`
	
	rows, err := q.db.QueryContext(ctx, query, flightID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	var seats []Seat
	for rows.Next() {
		var s Seat
		err := rows.Scan(&s.ID, &s.FlightID, &s.SeatNo, &s.Class, &s.CreatedAt, &s.UpdatedAt)
		if err != nil {
			return nil, err
		}
		seats = append(seats, s)
	}
	
	return seats, rows.Err()
}

func (q *Queries) CreateSeatLock(ctx context.Context, arg CreateSeatLockParams) error {
	query := `INSERT INTO seat_locks (flight_id, seat_no, holder_id, expires_at) 
	VALUES (?, ?, ?, ?)`
	
	_, err := q.db.ExecContext(ctx, query, arg.FlightID, arg.SeatNo, arg.HolderID, arg.ExpiresAt)
	return err
}

func (q *Queries) UpdateSeatLock(ctx context.Context, arg UpdateSeatLockParams) (int64, error) {
	query := `UPDATE seat_locks SET expires_at = ? 
	WHERE flight_id = ? AND seat_no = ? AND holder_id = ? AND expires_at > NOW()`
	
	result, err := q.db.ExecContext(ctx, query, arg.ExpiresAt, arg.FlightID, arg.SeatNo, arg.HolderID)
	if err != nil {
		return 0, err
	}
	
	return result.RowsAffected()
}

func (q *Queries) ConfirmSeatLock(ctx context.Context, arg ConfirmSeatLockParams) (int64, error) {
	query := `UPDATE seat_locks 
	          SET expires_at = '2038-01-01 00:00:00', updated_at = CURRENT_TIMESTAMP 
	          WHERE flight_id = ? AND seat_no = ? AND holder_id = ? AND expires_at > NOW()`
	
	result, err := q.db.ExecContext(ctx, query, arg.FlightID, arg.SeatNo, arg.HolderID)
	if err != nil {
		return 0, err
	}
	
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	
	return rowsAffected, nil
}

func (q *Queries) ReleaseSeatLock(ctx context.Context, arg ReleaseSeatLockParams) error {
	query := `DELETE FROM seat_locks 
	WHERE flight_id = ? AND seat_no = ? AND holder_id = ?`
	
	_, err := q.db.ExecContext(ctx, query, arg.FlightID, arg.SeatNo, arg.HolderID)
	return err
}

func (q *Queries) GetSeatLock(ctx context.Context, arg GetSeatLockParams) (SeatLock, error) {
	query := `SELECT id, flight_id, seat_no, holder_id, expires_at, created_at, updated_at 
	FROM seat_locks WHERE flight_id = ? AND seat_no = ? AND expires_at > NOW()`
	
	var lock SeatLock
	err := q.db.QueryRowContext(ctx, query, arg.FlightID, arg.SeatNo).Scan(
		&lock.ID, &lock.FlightID, &lock.SeatNo, &lock.HolderID, 
		&lock.ExpiresAt, &lock.CreatedAt, &lock.UpdatedAt,
	)
	
	return lock, err
}

func (q *Queries) CleanupExpiredLocks(ctx context.Context) error {
	query := `DELETE FROM seat_locks WHERE expires_at <= NOW()`
	
	_, err := q.db.ExecContext(ctx, query)
	return err
}

func (q *Queries) ListFlightSeatLocks(ctx context.Context, flightID int64) ([]SeatLock, error) {
	// This will be implemented by sqlc
	return []SeatLock{}, nil
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (int64, error) {
	query := `INSERT INTO tickets (flight_id, seat_no, user_id, price_amount, currency, pnr_code, payment_ref) 
	          VALUES (?, ?, ?, ?, ?, ?, ?)`
	
	result, err := q.db.ExecContext(ctx, query, 
		arg.FlightID, arg.SeatNo, arg.UserID, arg.PriceAmount, 
		arg.Currency, arg.PnrCode, arg.PaymentRef)
	if err != nil {
		return 0, err
	}
	
	id, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	
	return id, nil
}

func (q *Queries) GetTicket(ctx context.Context, id int64) (Ticket, error) {
	query := `SELECT id, flight_id, seat_no, user_id, price_amount, currency, 
	                 pnr_code, payment_ref, created_at, updated_at 
	          FROM tickets WHERE id = ?`
	
	var t Ticket
	var updatedAt time.Time
	err := q.db.QueryRowContext(ctx, query, id).Scan(
		&t.ID, &t.FlightID, &t.SeatNo, &t.UserID, &t.PriceAmount, &t.Currency,
		&t.PnrCode, &t.PaymentRef, &t.CreatedAt, &updatedAt)
	
	// Set IssuedAt to CreatedAt since we don't have a separate issued_at column
	t.IssuedAt = t.CreatedAt
	
	if err != nil {
		if err == sql.ErrNoRows {
			return Ticket{}, sql.ErrNoRows
		}
		return Ticket{}, err
	}
	
	return t, nil
}

func (q *Queries) GetTicketByPNR(ctx context.Context, pnrCode string) (Ticket, error) {
	// This will be implemented by sqlc
	return Ticket{}, nil
}

func (q *Queries) GetTicketByFlightSeat(ctx context.Context, arg GetTicketByFlightSeatParams) (Ticket, error) {
	query := `SELECT id, flight_id, seat_no, user_id, price_amount, currency, 
	                 pnr_code, payment_ref, created_at, updated_at 
	          FROM tickets 
	          WHERE flight_id = ? AND seat_no = ?`
	
	var t Ticket
	var updatedAt time.Time
	err := q.db.QueryRowContext(ctx, query, arg.FlightID, arg.SeatNo).Scan(
		&t.ID, &t.FlightID, &t.SeatNo, &t.UserID, &t.PriceAmount, &t.Currency,
		&t.PnrCode, &t.PaymentRef, &t.CreatedAt, &updatedAt)
	
	// Set IssuedAt to CreatedAt since we don't have a separate issued_at column
	t.IssuedAt = t.CreatedAt
	
	if err != nil {
		if err == sql.ErrNoRows {
			// Return an empty ticket and sql.ErrNoRows so the repository can handle it
			return Ticket{}, sql.ErrNoRows
		}
		return Ticket{}, err
	}
	
	return t, nil
}

func (q *Queries) ListUserTickets(ctx context.Context, userID string) ([]Ticket, error) {
	// This will be implemented by sqlc
	return []Ticket{}, nil
}

func (q *Queries) ListFlightTickets(ctx context.Context, flightID int64) ([]Ticket, error) {
	// This will be implemented by sqlc
	return []Ticket{}, nil
}

func (q *Queries) CreateIdempotencyKey(ctx context.Context, arg CreateIdempotencyKeyParams) error {
	// This will be implemented by sqlc
	return nil
}

func (q *Queries) GetIdempotencyKey(ctx context.Context, arg GetIdempotencyKeyParams) (IdempotencyKey, error) {
	// This will be implemented by sqlc
	return IdempotencyKey{}, nil
}
